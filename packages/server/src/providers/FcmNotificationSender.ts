import { Injectable, Logger } from '@nestjs/common'
import * as admin from 'firebase-admin'
import { credential } from 'firebase-admin'
import { ConfigService } from '@nestjs/config'
import * as fs from 'fs'
import { SendNotificationResponseDto } from 'src/websocket/dto/messagerepository-websocket.dto'

@Injectable()
export class FcmNotificationSender {
  private static instance: FcmNotificationSender
  private admin: admin.app.App
  private serviceAccount: any
  private isDataOnly: boolean

  /**
   * Constructor to initialize the FCM Notification Sender.
   * @param {ConfigService} configService - Service to access application configuration.
   */
  constructor(private readonly configService: ConfigService) {
    this.serviceAccount = this.getFirebaseConfig()

    if (!this.serviceAccount) {
      throw new Error('The serviceAccount configuration is empty or undefined.')
    }

    // Initialize Firebase Admin SDK with the service account credentials
    if (process.env.NODE_ENV !== 'test') {
      this.admin = admin.initializeApp({
        credential: credential.cert(this.serviceAccount),
      })
    }
    // Determine if notifications should be sent as data-only from environment variable
    this.isDataOnly = this.configService.get('appConfig.fcmDataOnly') === 'true'
  }

  /**
   * Singleton method to get the instance of FcmNotificationSender.
   * @param {ConfigService} configService - Service to access application configuration.
   * @returns {FcmNotificationSender} - The singleton instance of FcmNotificationSender.
   */
  public static getInstance(configService: ConfigService): FcmNotificationSender {
    if (!FcmNotificationSender.instance) {
      FcmNotificationSender.instance = new FcmNotificationSender(configService)
    }
    return FcmNotificationSender.instance
  }

  /**
   * Sends a push notification to a specific device using Firebase Cloud Messaging (FCM).
   * @param {string} registrationToken - The device token registered with FCM.
   * @param {string} messageId - The message ID generated by the Cloud-Agent addMessage method.
   * @returns {Promise<{ success: boolean, response?: any, message?: string, error?: any }>}
   * - An object indicating the success or failure of the notification sending process.
   */
  public async sendPushNotification(
    registrationToken: string,
    messageId: string,
  ): Promise<SendNotificationResponseDto> {
    try {
      Logger.debug(`[sendPushNotification] ** initialize to token: ${registrationToken} *** messageId: ${messageId} **`)

      const messagePayload: admin.messaging.Message = {
        token: registrationToken,
        data: {
          '@type': 'https://didcomm.org/push-notifications-fcm',
          message_id: messageId,
        },
        android: {
          collapseKey: 'generic-new-messages',
          priority: 'high',
          notification: {
            tag: 'generic-new-messages',
          },
          data: {
            contentAvailable: 'true',
          },
        },
        apns: {
          headers: {
            'apns-priority': '10',
            'apns-collapse-id': '0',
          },
          payload: {
            aps: {
              alert: {
                title: 'Hologram',
                body: 'You have new messages',
              },
              'content-available': 1,
              //sound: 'default',
              //'mutable-content': 1,
            },
            data: {
              '@type': 'https://didcomm.org/push-notifications-fcm',
              message_id: messageId,
            },
          },
        },
      }

      // Add notification content if it's not data-only
      if (!this.isDataOnly) {
        messagePayload.notification = {
          title: 'Hologram',
          body: 'You have new messages',
        }
      }
      Logger.debug(`*** messagePayload: ${JSON.stringify(messagePayload, null, 2)} ***`)
      // Send the message via FCM
      let response: any = ''
      if (process.env.NODE_ENV !== 'test') {
        response = await this.admin.messaging().send(messagePayload)
      } else {
        response = 'test succefully'
      }
      Logger.debug(`[sendPushNotification] Message sent successfully: ${response}`)

      return { success: true, response }
    } catch (error) {
      Logger.error('[sendPushNotification] Error sending notification:', error.message || error)
      return { error: error.message || error }
    }
  }

  /**
   * Reads and parses the Firebase service account configuration from a JSON file.
   * @returns {any | null} - The parsed service account configuration, or null if the file could not be read.
   */
  private getFirebaseConfig(): any | null {
    try {
      const firebasePath = this.configService.get('appConfig.firebaseCfgFile')
      Logger.debug(`[getFirebaseConfig] Firebase config file path: ${firebasePath}`)
      const filePath = `${firebasePath}`

      // Check if the configuration file exists
      if (!fs.existsSync(filePath)) {
        Logger.error(`[getFirebaseConfig] Firebase config file not found at path: ${filePath}`)
        return null
      }

      // Read and parse the JSON configuration file
      const jsonData = fs.readFileSync(filePath, 'utf8')
      if (jsonData) {
        Logger.debug(`[getFirebaseConfig] Firebase config was read successfully`)
      }
      const fcmConfig = JSON.parse(jsonData)

      return fcmConfig
    } catch (error) {
      Logger.error('Error reading Firebase config file:', error.message)
      return null
    }
  }
}
