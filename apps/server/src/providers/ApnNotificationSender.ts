import { Injectable, Logger } from '@nestjs/common'
import * as apn from 'apn'
import { ConfigService } from '@nestjs/config'
import * as fs from 'fs'
import { SendNotificationResponseDto } from '../websocket/dto/messagerepository-websocket.dto'

@Injectable()
export class ApnNotificationSender {
  private apnProvider: apn.Provider | null = null
  private isDataOnly: boolean
  private keyPath: string

  /**
   * Constructor to initialize the APN Notification Sender.
   * Attempts to initialize the APN provider with the configuration from a file.
   * If the initialization fails, the application continues running with a null provider.
   *
   * @param {ConfigService} configService - Service to access application configuration.
   */
  public constructor(private readonly configService: ConfigService) {
    try {
      const apnConfig = this.getApnConfig()

      if (!apnConfig) {
        throw new Error('The APNs configuration is empty or undefined.')
      }

      /// key path file key .p8
      this.keyPath = this.configService.get('appConfig.apnsPathKey')

      // Verify file path exist
      if (!fs.existsSync(this.keyPath)) {
        throw new Error(`Key file not found at: ${this.keyPath}`)
      }

      // Attempt to initialize the APN provider
      this.apnProvider = new apn.Provider({
        token: {
          key: fs.readFileSync(this.keyPath),
          keyId: apnConfig.keyId,
          teamId: apnConfig.teamId,
        },
        production: apnConfig.production,
      })

      Logger.debug('APN Provider initialized successfully.')
    } catch (error) {
      // Log the error and allow the application to continue running
      Logger.error('Failed to initialize APN Provider:', error)
      this.apnProvider = null // Set to null to indicate failure
    }

    // Determine if notifications should be data-only based on environment variable
    this.isDataOnly = this.configService.get('appConfig.notificationDataOnly') === 'true'
  }

  /**
   * Sends a push notification to a specific device using Apple Push Notification service (APNs).
   *
   * @param {string} token - The device token registered with APNs.
   * @param {string} messageId - The message ID generated by the Cloud-Agent addMessage method.
   * @returns {Promise<SendNotificationResponseDto>} -
   * An object indicating the success or failure of the notification sending process.
   */
  public async sendPushNotification(token: string, messageId: string): Promise<SendNotificationResponseDto> {
    const context = 'ApnNotificationService'

    // Ensure the APN provider is initialized
    if (!this.apnProvider) {
      Logger.warn('[sendPushNotification] APN Provider is not initialized. Skipping push notification.', context)
      return { success: false, response: 'APN Provider not initialized', error: undefined }
    }

    try {
      Logger.debug(
        `[sendPushNotification] Initializing push notification for token: ${token}, messageId: ${messageId}`,
        context,
      )

      // Build the notification payload
      const notification = new apn.Notification({
        payload: {
          message_id: messageId,
          '@type': 'https://didcomm.org/push-notifications-apns',
        },
        topic: this.configService.get('appConfig.apnsTopic'),
      })

      // Add alert if the notification is not data-only
      if (!this.isDataOnly) {
        notification.alert = {
          title: 'Hologram',
          body: 'You have new messages',
        }
      }

      // Send the notification via APNs
      const result = await this.apnProvider.send(notification, token)

      if (result.sent.length > 0) {
        Logger.debug(`[sendPushNotification] Message sent successfully to ${result.sent.length} device(s)`, context)
        return { success: true, response: `Message sent to ${result.sent.length} device(s)` }
      } else {
        Logger.warn(`[sendPushNotification] Failed to send notification to ${result.failed.length} device(s)`, context)
        return { success: false, response: `Failed to send notification to ${result.failed.length} device(s)` }
      }
    } catch (error) {
      Logger.error('[sendPushNotification] Error sending notification:', error, context)
      return { error: error.message || 'Error sending notification', success: undefined, response: undefined }
    }
  }

  /**
   * Reads and parses the APNs configuration from a JSON file.
   * The configuration includes the key, keyId, teamId, and environment (production/sandbox).
   *
   * @returns {any | null} - The parsed APNs configuration, or null if the file could not be read.
   */
  private getApnConfig(): any | null {
    try {
      const apnConfigPath = this.configService.get('appConfig.apnConfigFile')
      Logger.debug(`[getApnConfig] APNs config file path: ${apnConfigPath}`)

      // Check if the APNs configuration file exists
      if (!fs.existsSync(apnConfigPath)) {
        Logger.error(`[getApnConfig] APNs config file not found at path: ${apnConfigPath}`)
        return null
      }

      // Read and parse the APNs configuration file
      const apnConfig = JSON.parse(fs.readFileSync(apnConfigPath, 'utf8'))
      if (apnConfig) {
        Logger.debug(`[getApnConfig] APNs config read successfully`)
      }

      return apnConfig
    } catch (error) {
      Logger.error('Error reading APNs config file:', error.message)
      return null
    }
  }
}
